<!doctype html><html lang=en><head><title>Calling Rust Functions from R using extendr - II · The Journeyman Modeler
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Journeyman Modeler"><meta name=description content="In a previous post, I called a Rust function from R and did a speed test of that function against an equivalent R function. At the end of the post, I mentioned that we could use memoization to speed up the R function. I proceed to do that here.
The speed test in the previous post might have been unfair to R, since it is well known that R is not good with recursive function calls. I now create a memoized version of the R function here:"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Calling Rust Functions from R using extendr - II"><meta name=twitter:description content="In a previous post, I called a Rust function from R and did a speed test of that function against an equivalent R function. At the end of the post, I mentioned that we could use memoization to speed up the R function. I proceed to do that here.
The speed test in the previous post might have been unfair to R, since it is well known that R is not good with recursive function calls. I now create a memoized version of the R function here:"><meta property="og:url" content="http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/"><meta property="og:site_name" content="The Journeyman Modeler"><meta property="og:title" content="Calling Rust Functions from R using extendr - II"><meta property="og:description" content="In a previous post, I called a Rust function from R and did a speed test of that function against an equivalent R function. At the end of the post, I mentioned that we could use memoization to speed up the R function. I proceed to do that here.
The speed test in the previous post might have been unfair to R, since it is well known that R is not good with recursive function calls. I now create a memoized version of the R function here:"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-05-03T00:00:00+00:00"><meta property="article:modified_time" content="2025-05-03T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="R"><link rel=canonical href=http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.38c4552ac40f9ae3408bad40358f654ebd8804412fe74ed56f2d6c8a7af82dd3.css integrity="sha256-OMRVKsQPmuNAi61ANY9lTr2IBEEv507Vby1sinr4LdM=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://jmodeler.github.io/>The Journeyman Modeler
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/>Calling Rust Functions from R using extendr - II</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2025-05-03T00:00:00Z>May 3, 2025
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
3-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/rust/>Rust</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/r/>R</a></span></div></div></header><div class=post-content><p>In a <a href=https://jmodeler.github.io/posts/2025-04-27-calling-rust-functions-from-r-using-extendr/ class=external-link target=_blank rel=noopener>previous post</a>, I called a Rust function from R and did a speed test of that function against an equivalent R function. At the end of the post, I mentioned that we could use <a href=https://en.wikipedia.org/wiki/Memoization class=external-link target=_blank rel=noopener>memoization</a> to speed up the R function. I proceed to do that here.</p><p>The speed test in the previous post might have been unfair to R, since it is well known that <a href=https://stackoverflow.com/questions/6807068/why-is-my-recursive-function-so-slow-in-r class=external-link target=_blank rel=noopener>R is not good with recursive function calls</a>. I now create a memoized version of the R function here:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>library</span><span class=p>(</span><span class=n>rextendr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>library</span><span class=p>(</span><span class=n>ggplot2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>library</span><span class=p>(</span><span class=n>microbenchmark</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># write memoized r function</span>
</span></span><span class=line><span class=cl><span class=n>fibonacci</span> <span class=o>&lt;-</span> <span class=kr>function</span><span class=p>(</span><span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>fib</span> <span class=o>&lt;-</span> <span class=nf>vector</span><span class=p>(</span><span class=s>&#39;numeric&#39;</span><span class=p>,</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=kr>for</span><span class=p>(</span><span class=n>ii</span> <span class=kr>in</span> <span class=m>1</span><span class=o>:</span><span class=p>(</span><span class=n>n</span><span class=m>+1</span><span class=p>))</span> <span class=p>{</span> 
</span></span><span class=line><span class=cl>    <span class=c1># R vector indices start at 1</span>
</span></span><span class=line><span class=cl>    <span class=kr>if</span><span class=p>(</span><span class=n>ii</span><span class=o>==</span><span class=m>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>fib[ii]</span> <span class=o>&lt;-</span> <span class=m>0</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=kr>else</span> <span class=kr>if</span><span class=p>(</span><span class=n>ii</span><span class=o>==</span><span class=m>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>fib[ii]</span> <span class=o>&lt;-</span> <span class=m>1</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=kr>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>fib[ii]</span> <span class=o>&lt;-</span> <span class=n>fib[ii</span><span class=m>-1</span><span class=n>]</span> <span class=o>+</span> <span class=n>fib[ii</span><span class=m>-2</span><span class=n>]</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=kr>return</span><span class=p>(</span><span class=n>fib[n</span><span class=m>+1</span><span class=n>]</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># run the R function</span>
</span></span><span class=line><span class=cl><span class=n>r_fn_result</span> <span class=o>=</span> <span class=nf>fibonacci</span><span class=p>(</span><span class=m>15</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>print</span><span class=p>(</span><span class=n>r_fn_result</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>## [1] 610
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1># test run time for a larger term number</span>
</span></span><span class=line><span class=cl><span class=nf>system.time</span><span class=p>(</span><span class=nf>fibonacci</span><span class=p>(</span><span class=m>40</span><span class=p>))</span>
</span></span></code></pre></div><pre tabindex=0><code>##    user  system elapsed 
##       0       0       0
</code></pre><p>Note that the function returns the correct value for the <code>\(15^{th}\)</code> term and is much faster now for generating the value of the 40th Fibonacci term (it&rsquo;s even faster than the Rust function, which uses recursive function calls &ndash; <a href=https://jmodeler.github.io/posts/2025-04-27-calling-rust-functions-from-r-using-extendr/ class=external-link target=_blank rel=noopener>see the previous post</a>)</p><p>I now write a memoized version of the Rust function, and call it in R:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1># write memoized Rust function</span>
</span></span><span class=line><span class=cl><span class=n>rust_memoized_code</span> <span class=o>&lt;-</span> <span class=s>&#34;
</span></span></span><span class=line><span class=cl><span class=s>#[extendr]
</span></span></span><span class=line><span class=cl><span class=s>fn fibonacci_rust(n:usize) -&gt; i64 {
</span></span></span><span class=line><span class=cl><span class=s>  let mut fibn: Vec&lt;i64&gt; = vec![0;(n+1)];
</span></span></span><span class=line><span class=cl><span class=s>  for ii in 0..=n {
</span></span></span><span class=line><span class=cl><span class=s>    if ii==0 {
</span></span></span><span class=line><span class=cl><span class=s>    fibn[ii] = 0;
</span></span></span><span class=line><span class=cl><span class=s>  } else if ii==1 {
</span></span></span><span class=line><span class=cl><span class=s>    fibn[ii] = 1;
</span></span></span><span class=line><span class=cl><span class=s>  } else {
</span></span></span><span class=line><span class=cl><span class=s>    fibn[ii] = fibn[ii-1] + fibn[ii-2];
</span></span></span><span class=line><span class=cl><span class=s>  }
</span></span></span><span class=line><span class=cl><span class=s>  }
</span></span></span><span class=line><span class=cl><span class=s>  return fibn[n];
</span></span></span><span class=line><span class=cl><span class=s>}&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># compile source code</span>
</span></span><span class=line><span class=cl><span class=nf>rust_source</span><span class=p>(</span><span class=n>code</span> <span class=o>=</span> <span class=n>rust_memoized_code</span><span class=p>,</span> <span class=n>quiet</span><span class=o>=</span><span class=kc>TRUE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># run the rust function</span>
</span></span><span class=line><span class=cl><span class=n>rustm_fn_result</span> <span class=o>=</span> <span class=nf>fibonacci_rust</span><span class=p>(</span><span class=m>15</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>print</span><span class=p>(</span><span class=n>rustm_fn_result</span><span class=p>)</span>
</span></span></code></pre></div><pre tabindex=0><code>## [1] 610
</code></pre><p>Which, again is the correct value for the <code>\(15^{th}\)</code> term. I now do a microbenchmark test:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1># use microbenchmark to compare runtimes</span>
</span></span><span class=line><span class=cl><span class=c1># list of test values</span>
</span></span><span class=line><span class=cl><span class=n>values</span> <span class=o>&lt;-</span> <span class=nf>c</span><span class=p>(</span><span class=m>40</span><span class=p>,</span> <span class=m>50</span><span class=p>,</span> <span class=m>60</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1># list to store microbenchmark results</span>
</span></span><span class=line><span class=cl><span class=n>compare</span> <span class=o>&lt;-</span> <span class=nf>vector</span><span class=p>(</span><span class=s>&#39;list&#39;</span><span class=p>,</span> <span class=nf>length</span><span class=p>(</span><span class=n>values</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=kr>for</span> <span class=p>(</span><span class=n>ii</span> <span class=kr>in</span> <span class=m>1</span><span class=o>:</span><span class=nf>length</span><span class=p>(</span><span class=n>values</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>compare[[ii]]</span> <span class=o>&lt;-</span> <span class=nf>microbenchmark</span><span class=p>(</span><span class=nf>fibonacci</span><span class=p>(</span><span class=n>values[ii]</span><span class=p>),</span> <span class=nf>fibonacci_rust</span><span class=p>(</span><span class=n>values[ii]</span><span class=p>),</span> <span class=n>times</span> <span class=o>=</span> <span class=m>1000</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1># Change labels for plotting convenience later</span>
</span></span><span class=line><span class=cl>  <span class=c1># Convert expressions to character strings</span>
</span></span><span class=line><span class=cl>  <span class=n>expr_char</span> <span class=o>&lt;-</span> <span class=nf>as.character</span><span class=p>(</span><span class=n>compare[[ii]]</span><span class=o>$</span><span class=n>expr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1># Map to new labels</span>
</span></span><span class=line><span class=cl>  <span class=n>expr_char[expr_char</span> <span class=o>==</span> <span class=s>&#34;fibonacci(values[ii])&#34;</span><span class=n>]</span> <span class=o>&lt;-</span> <span class=s>&#34;R&#34;</span>
</span></span><span class=line><span class=cl>  <span class=n>expr_char[expr_char</span> <span class=o>==</span> <span class=s>&#34;fibonacci_rust(values[ii])&#34;</span><span class=n>]</span> <span class=o>&lt;-</span> <span class=s>&#34;Rust&#34;</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  <span class=c1># Assign the new factor with correct levels</span>
</span></span><span class=line><span class=cl>  <span class=n>compare[[ii]]</span><span class=o>$</span><span class=n>expr</span> <span class=o>&lt;-</span> <span class=nf>factor</span><span class=p>(</span><span class=n>expr_char</span><span class=p>,</span> <span class=n>levels</span> <span class=o>=</span> <span class=nf>c</span><span class=p>(</span><span class=s>&#34;R&#34;</span><span class=p>,</span> <span class=s>&#34;Rust&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># plot benchmark times, term number = 40</span>
</span></span><span class=line><span class=cl><span class=nf>autoplot</span><span class=p>(</span><span class=n>compare[[1]]</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>  <span class=nf>ggtitle</span><span class=p>(</span><span class=nf>sprintf</span><span class=p>(</span><span class=s>&#34;Rust vs R: Microbenchmark Results for Term Number: %d&#34;</span><span class=p>,</span> <span class=n>values[1]</span><span class=p>))</span>
</span></span></code></pre></div><img src=http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/index.en_files/figure-html/unnamed-chunk-3-1.png width=672><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1># plot benchmark times, term number = 50</span>
</span></span><span class=line><span class=cl><span class=nf>autoplot</span><span class=p>(</span><span class=n>compare[[2]]</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>  <span class=nf>ggtitle</span><span class=p>(</span><span class=nf>sprintf</span><span class=p>(</span><span class=s>&#34;Rust vs R: Microbenchmark Results for Term Number: %d&#34;</span><span class=p>,</span> <span class=n>values[2]</span><span class=p>))</span>
</span></span></code></pre></div><img src=http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/index.en_files/figure-html/unnamed-chunk-3-2.png width=672><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1># plot benchmark times, term number = 60</span>
</span></span><span class=line><span class=cl><span class=nf>autoplot</span><span class=p>(</span><span class=n>compare[[3]]</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>  <span class=nf>ggtitle</span><span class=p>(</span><span class=nf>sprintf</span><span class=p>(</span><span class=s>&#34;Rust vs R: Microbenchmark Results for Term Number: %d&#34;</span><span class=p>,</span> <span class=n>values[3]</span><span class=p>))</span>
</span></span></code></pre></div><img src=http://jmodeler.github.io/posts/2025-05-03-calling-rust-functions-from-r-using-extendr-ii/index.en_files/figure-html/unnamed-chunk-3-3.png width=672><p>Note that while the R function appears to be faster when <em>n=40</em>, the Rust function tends to do better speed wise when <em>n</em> gets larger. That said, the Rust function appears to have instances where it runs much longer than the R function.</p></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2023 -
2025
Journeyman Modeler
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>