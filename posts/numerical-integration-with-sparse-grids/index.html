<!doctype html><html lang=en><head><title>Numerical Integration with Sparse Grids · The Journeyman Modeler
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Journeyman Modeler"><meta name=description content="I recently read a paper (Heiss and Winschel 2008) that advocated the use of certain techniques (Sparse Grids, SG henceforth) in numerical integration to calculate likelihood functions, as opposed to using Monte Carlo (MC henceforth) methods for the same. While approximating integrals with MC methods are simpler to implement, they might lead to integral values with considerable simulation error (Skrainka and Judd 2011). This post attempts to demonstrate the claim in Skrainka and Judd (2011) using two very simple integrals, to which we already know the value. I attempt to compare the outcomes from using MC and SG."><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Numerical Integration with Sparse Grids"><meta name=twitter:description content="I recently read a paper (Heiss and Winschel 2008) that advocated the use of certain techniques (Sparse Grids, SG henceforth) in numerical integration to calculate likelihood functions, as opposed to using Monte Carlo (MC henceforth) methods for the same. While approximating integrals with MC methods are simpler to implement, they might lead to integral values with considerable simulation error (Skrainka and Judd 2011). This post attempts to demonstrate the claim in Skrainka and Judd (2011) using two very simple integrals, to which we already know the value. I attempt to compare the outcomes from using MC and SG."><meta property="og:url" content="http://jmodeler.github.io/posts/numerical-integration-with-sparse-grids/"><meta property="og:site_name" content="The Journeyman Modeler"><meta property="og:title" content="Numerical Integration with Sparse Grids"><meta property="og:description" content="I recently read a paper (Heiss and Winschel 2008) that advocated the use of certain techniques (Sparse Grids, SG henceforth) in numerical integration to calculate likelihood functions, as opposed to using Monte Carlo (MC henceforth) methods for the same. While approximating integrals with MC methods are simpler to implement, they might lead to integral values with considerable simulation error (Skrainka and Judd 2011). This post attempts to demonstrate the claim in Skrainka and Judd (2011) using two very simple integrals, to which we already know the value. I attempt to compare the outcomes from using MC and SG."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-20T07:55:39-04:00"><meta property="article:tag" content="Numerical Integration"><meta property="article:tag" content="Sparse Grids"><link rel=canonical href=http://jmodeler.github.io/posts/numerical-integration-with-sparse-grids/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.38c4552ac40f9ae3408bad40358f654ebd8804412fe74ed56f2d6c8a7af82dd3.css integrity="sha256-OMRVKsQPmuNAi61ANY9lTr2IBEEv507Vby1sinr4LdM=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=http://jmodeler.github.io/>The Journeyman Modeler
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>About</a></li><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li></ul></section><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}},window.addEventListener("load",e=>{document.querySelectorAll("mjx-container").forEach(function(e){e.parentElement.classList+="has-jax"})})</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=http://jmodeler.github.io/posts/numerical-integration-with-sparse-grids/>Numerical Integration with Sparse Grids</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2023-03-20T00:00:00Z>March 20, 2023
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
5-minute read</span></div><div class=categories><i class="fa-solid fa-folder" aria-hidden=true></i>
<a href=/categories/scientific-computing/>Scientific Computing</a></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/numerical-integration/>Numerical Integration</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/sparse-grids/>Sparse Grids</a></span></div></div></header><div class=post-content><p>I recently read a paper (<a href=#ref-heiss2008likelihood>Heiss and Winschel 2008</a>) that advocated the use of certain techniques (Sparse Grids, SG henceforth) in numerical integration to calculate likelihood functions, as opposed to using Monte Carlo (MC henceforth) methods for the same. While approximating integrals with MC methods are simpler to implement, they might lead to integral values with considerable simulation error (<a href=#ref-skrainka2011high>Skrainka and Judd 2011</a>). This post attempts to demonstrate the claim in Skrainka and Judd (<a href=#ref-skrainka2011high>2011</a>) using two very simple integrals, to which we already know the value. I attempt to compare the outcomes from using MC and SG.</p><p>The integrals I’ll be evaluating are:
<code>\begin{equation} \int_{-\infty}^{\infty} \left( \sum_{i=1}^{5} x_i \right) dF_{X} \tag{1} \end{equation}</code></p><p>and
<code>\begin{equation} \int_{-\infty}^{\infty} \left( \prod_{i=1}^{5} x_i^2 \right) dF_{X} \tag{2} \end{equation}</code></p><p>where <code>\(X = \{x_i\}_{i=1}^{5}\)</code> is a five dimensional random variable, which is distributed according to the multivariate standard normal:</p><p><code>\begin{equation} X \sim N\left( \left[ \begin{array} {r} 0 \\ 0 \\ 0 \\ 0 \\ 0 \\ \end{array}\right], \left[ \begin{array} {rrrrr} 1 & 0 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 \\ \end{array}\right] \right) \end{equation}</code></p><p>Given the distribution of <code>\(X\)</code>, the values of the integrals above are easily obtained from standard results (the value of (1) is <code>\(0\)</code> and that of (2) is <code>\(1\)</code>) respectively.</p><p>I write some utility functions in R to compute the integrands above:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1>#function to compute the sum of components of the random vector</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>&lt;-</span> <span class=kr>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>return</span><span class=p>(</span><span class=nf>sum</span><span class=p>(</span><span class=n>x</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#function to compute the square product of the components of the random vector</span>
</span></span><span class=line><span class=cl><span class=n>p</span> <span class=o>&lt;-</span> <span class=kr>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>return</span><span class=p>(</span><span class=nf>prod</span><span class=p>(</span><span class=n>x^2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>I now write a function that:</p><ul><li>Simulates a certain number of draws from the distribution of the random variable <code>\(X\)</code></li><li>Computes the integrand function using each of these draws as input</li><li>Takes the average of the values computed in the previous step</li></ul><p>This function, in effect, would give us the approximate value of the integral via MC methodology.</p><p>The code is provided below, note that I use the <tt><a href=https://cran.r-project.org/web/packages/mvtnorm/index.html class=external-link target=_blank rel=noopener>mvtnorm</a></tt> package to create random draws.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>library</span><span class=p>(</span><span class=n>mvtnorm</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#Function to calculate the MC approximation for the integral</span>
</span></span><span class=line><span class=cl><span class=n>mc_int</span> <span class=o>&lt;-</span> <span class=kr>function</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span><span class=p>,</span> <span class=n>sigma</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>#generate random draws</span>
</span></span><span class=line><span class=cl>  <span class=n>x</span> <span class=o>&lt;-</span> <span class=nf>rmvnorm</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=n>mean</span> <span class=o>=</span> <span class=n>mu</span><span class=p>,</span> <span class=n>sigma</span> <span class=o>=</span> <span class=n>sigma</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=c1>#now get the integral</span>
</span></span><span class=line><span class=cl>  <span class=n>mc_int_n</span> <span class=o>&lt;-</span> <span class=nf>mean</span><span class=p>(</span><span class=nf>apply</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=n>s</span><span class=p>))</span>
</span></span><span class=line><span class=cl>  <span class=kr>return</span><span class=p>(</span><span class=n>mc_int_n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>set.seed</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>&lt;-</span> <span class=m>1000</span>
</span></span><span class=line><span class=cl><span class=n>mc_val</span> <span class=o>&lt;-</span> <span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>mc_val</span>
</span></span></code></pre></div><pre><code>## [1] 0.007150433
</code></pre><p>The result, 0.00715 is not far off from the true value of <code>\(0\)</code> at first glance, however, we need to compare this to the result from the SG approach.</p><p>R has a package that generates sparse grids for numerical integration as described in Heiss and Winschel (<a href=#ref-heiss2008likelihood>2008</a>), called <tt><a href=https://cran.r-project.org/web/packages/SparseGrid/index.html class=external-link target=_blank rel=noopener>SparseGrid</a></tt>. We now use the nodes and weights generated from this package to approximate the first integral.
I re-use some of the code provided in the documentation for the <tt><a href=https://cran.r-project.org/web/packages/SparseGrid/vignettes/SparseGrid.pdf class=external-link target=_blank rel=noopener>SparseGrid</a></tt> package in R.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>library</span><span class=p>(</span><span class=n>SparseGrid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>#generate sparse grids for a 5 dimensional RV with accuracy level 2</span>
</span></span><span class=line><span class=cl><span class=n>sg</span> <span class=o>&lt;-</span> <span class=nf>createSparseGrid</span><span class=p>(</span><span class=n>type</span><span class=o>=</span><span class=s>&#39;KPN&#39;</span><span class=p>,</span> <span class=n>dimension</span><span class=o>=</span><span class=m>5</span><span class=p>,</span> <span class=n>k</span><span class=o>=</span><span class=m>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sg_int</span> <span class=o>&lt;-</span> <span class=kr>function</span><span class=p>(</span><span class=n>func</span><span class=p>,</span> <span class=n>sg</span><span class=p>,</span> <span class=kc>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>gx</span> <span class=o>&lt;-</span> <span class=nf>apply</span><span class=p>(</span><span class=n>sg</span><span class=o>$</span><span class=n>nodes</span><span class=p>,</span> <span class=m>1</span><span class=p>,</span> <span class=kr>function</span><span class=p>(</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span><span class=nf>func</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=kc>...</span><span class=p>)})</span>
</span></span><span class=line><span class=cl>  <span class=kr>return</span><span class=p>(</span><span class=nf>sum</span><span class=p>(</span><span class=n>gx</span> <span class=o>*</span> <span class=n>sg</span><span class=o>$</span><span class=n>weights</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>sg_val</span> <span class=o>&lt;-</span> <span class=nf>sg_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sg_val</span>
</span></span></code></pre></div><pre><code>## [1] 0
</code></pre><p>The result here is exactly 0. In light of this finding, the value obtained from the MC approach, in comparison, is a little off, and tends to show a high variance in output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>set.seed</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 0.007150433
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 0.03162326
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] -0.1287932
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 0.01040134
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] -0.03798655
</code></pre><p>In the third case, there is a <code>\(-12\%\)</code> error(!) in the value of the computed integral when compared to the result from the SG approach. The SG approach, in addition, shows no such variation in repeated runs, since the grid values and weights are fixed for a given accuracy level and dimension (of the variable being integrated).</p><p>I repeat the calculations for the second integral, as shown below</p><p>MC approach:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>set.seed</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>n</span> <span class=o>&lt;-</span> <span class=m>1000</span>
</span></span><span class=line><span class=cl><span class=n>mc_val</span> <span class=o>&lt;-</span> <span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>mc_val</span>
</span></span></code></pre></div><pre><code>## [1] 1.001089
</code></pre><p>SG approach:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=c1>#generate sparse grids for a 5 dimensional RV with accuracy level 6</span>
</span></span><span class=line><span class=cl><span class=n>sg</span> <span class=o>&lt;-</span> <span class=nf>createSparseGrid</span><span class=p>(</span><span class=n>type</span><span class=o>=</span><span class=s>&#39;KPN&#39;</span><span class=p>,</span> <span class=n>dimension</span><span class=o>=</span><span class=m>5</span><span class=p>,</span> <span class=n>k</span><span class=o>=</span><span class=m>6</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sg_val</span> <span class=o>&lt;-</span> <span class=nf>sg_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>sg</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>sg_val</span>
</span></span></code></pre></div><pre><code>## [1] 1
</code></pre><p>Once again, the SG approach gives us an exact value (note that the value of <code>\(k\)</code>, the accuracy level, has gone up, since the integrand is a higher order function). Again, the difference of the results between the two approaches doesn’t seem that large. However, variability of the results from the MC approach is still a concern, as shown below:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>set.seed</span><span class=p>(</span><span class=m>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 1.001089
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 0.4672555
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 1.14692
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 1.062975
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-r data-lang=r><span class=line><span class=cl><span class=nf>mc_int</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>n</span><span class=p>,</span> <span class=n>mu</span> <span class=o>=</span> <span class=nf>rep</span><span class=p>(</span><span class=m>0</span><span class=p>,</span><span class=m>5</span><span class=p>),</span> <span class=n>sigma</span> <span class=o>=</span> <span class=nf>diag</span><span class=p>(</span><span class=m>5</span><span class=p>))</span>
</span></span></code></pre></div><pre><code>## [1] 0.9112416
</code></pre><p>In the second case, there is a roughly <code>\(53\%\)</code> (!!) error when compared to the true value of the integral. This variability could be worse with more complicated integrands. One suggestion to reduce variability in MC methods is to increase the number of draws, but that would entail a lot of calculations and result in longer runtimes.</p><p>To conclude, we have shown with this simple example how results from numerical integration using MC methods have high variability, and more often than not, it would be good idea to increase the number of draws being used to approximate an integral, or use a different method altogether (SG).</p><h2 id=references>References
<a class=heading-link href=#references><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><div id=refs class="references csl-bib-body hanging-indent" entry-spacing=0><div id=ref-mvt class=csl-entry><p>Genz, Alan, Frank Bretz, Tetsuhisa Miwa, Xuefei Mi, Friedrich Leisch, Fabian Scheipl, and Torsten Hothorn. 2019. <em><span class=nocase>mvtnorm</span>: Multivariate Normal and t Distributions</em>. <a href="https://CRAN.R-project.org/package=mvtnorm" class=external-link target=_blank rel=noopener>https://CRAN.R-project.org/package=mvtnorm</a>.</p></div><div id=ref-heiss2008likelihood class=csl-entry><p>Heiss, Florian, and Viktor Winschel. 2008. “Likelihood Approximation by Numerical Integration on Sparse Grids.” <em>Journal of Econometrics</em> 144 (1): 62–80.</p></div><div id=ref-skrainka2011high class=csl-entry><p>Skrainka, Benjamin S, and Kenneth L Judd. 2011. “High Performance Quadrature Rules: How Numerical Integration Affects a Popular Model of Product Differentiation.” <em>Available at SSRN 1870703</em>.</p></div></div></div><footer></footer></article><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})'></script></section></div><footer class=footer><section class=container>©
2023 -
2025
Journeyman Modeler
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script></body></html>